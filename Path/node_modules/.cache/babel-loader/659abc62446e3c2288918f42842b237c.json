{"ast":null,"code":"export function aStar(nodes, startNode, endNode) {\n  const nodesVisited = [];\n  startNode.distanceFromStart = 0;\n  startNode.estimatedDistanceToEnd = calculateManhattanDistance(startNode, endNode);\n  const nodesToVisit = new MinHeap([startNode]);\n\n  while (!nodesToVisit.isEmpty()) {\n    const currentMinDistanceNode = nodesToVisit.remove();\n    nodesVisited.push(currentMinDistanceNode);\n    if (currentMinDistanceNode === endNode) break;\n    const neighbors = getNeighboringNodes(currentMinDistanceNode, nodes);\n\n    for (const neighbor of neighbors) {\n      if (neighbor.isWall) continue;\n      const tentativeDistanceToNeighbor = neighbor.isWeight ? currentMinDistanceNode.distanceFromStart + 7 : currentMinDistanceNode.distanceFromStart + 1;\n      if (tentativeDistanceToNeighbor >= neighbor.distanceFromStart) continue;\n      neighbor.previousNode = currentMinDistanceNode;\n      neighbor.distanceFromStart = tentativeDistanceToNeighbor;\n      neighbor.estimatedDistanceToEnd = tentativeDistanceToNeighbor + calculateManhattanDistance(neighbor, endNode);\n\n      if (!nodesToVisit.containsNode(neighbor)) {\n        nodesToVisit.insert(neighbor);\n      } else {\n        nodesToVisit.update(neighbor);\n      }\n    }\n  }\n\n  return nodesVisited;\n}\n\nfunction calculateManhattanDistance(currentNode, endNode) {\n  const currentRow = currentNode.row;\n  const currentCol = currentNode.col;\n  const endRow = endNode.row;\n  const endCol = endNode.col;\n  return Math.abs(currentRow - endRow) + Math.abs(currentCol - endCol);\n}\n\nfunction getNeighboringNodes(node, grid) {\n  const neighbors = [];\n  const {\n    col,\n    row\n  } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n\n  if (row > 0 && row % 2 === 1 && col < grid[0].length - 1) {\n    grid[row - 1][col + 1].diagonal = true;\n    neighbors.push(grid[row - 1][col + 1]);\n  }\n\n  if (row > 0 && row % 2 === 0 && col > 0) {\n    grid[row - 1][col - 1].diagonal = true;\n    neighbors.push(grid[row - 1][col - 1]);\n  }\n\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n\n  if (row < grid.length - 1 && row % 2 === 1 && col < grid[0].length - 1) {\n    grid[row + 1][col + 1].diagonal = true;\n    neighbors.push(grid[row + 1][col + 1]);\n  }\n\n  if (row < grid.length - 1 && row % 2 === 0 && col > 0) {\n    grid[row + 1][col - 1].diagonal = true;\n    neighbors.push(grid[row + 1][col - 1]);\n  }\n\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nclass MinHeap {\n  constructor(array) {\n    this.nodePositionsInHeap = array.reduce((obj, node, i) => {\n      obj[node.id] = i;\n      return obj;\n    }, {});\n    this.heap = this.buildHeap(array);\n  }\n\n  isEmpty() {\n    return this.heap.length == 0;\n  }\n\n  buildHeap(array) {\n    const firstParentIdx = Math.floor((array.length - 2) / 2);\n\n    for (let currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n      this.siftDown(currentIdx, array.length - 1, array);\n    }\n\n    return array;\n  }\n\n  siftDown(currentIdx, endIdx, heap) {\n    let childOneIdx = currentIdx * 2 + 1;\n\n    while (childOneIdx <= endIdx) {\n      const childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n      let idxToSwap;\n\n      if (childTwoIdx !== -1 && heap[childTwoIdx].estimatedDistanceToEnd < heap[childOneIdx].estimatedDistanceToEnd) {\n        idxToSwap = childTwoIdx;\n      } else {\n        idxToSwap = childOneIdx;\n      }\n\n      if (heap[idxToSwap].estimatedDistanceToEnd < heap[currentIdx].estimatedDistanceToEnd) {\n        this.swap(currentIdx, idxToSwap, heap);\n        currentIdx = idxToSwap;\n        childOneIdx = currentIdx * 2 + 1;\n      } else {\n        return;\n      }\n    }\n  }\n\n  siftUp(currentIdx, heap) {\n    let parentIdx = Math.floor((currentIdx - 1) / 2);\n\n    while (currentIdx > 0 && heap[currentIdx].estimatedDistanceToEnd < heap[parentIdx].estimatedDistanceToEnd) {\n      this.swap(currentIdx, parentIdx, heap);\n      currentIdx = parentIdx;\n      parentIdx = Math.floor((currentIdx - 1) / 2);\n    }\n  }\n\n  remove() {\n    if (this.isEmpty()) return;\n    this.swap(0, this.heap.length - 1, this.heap);\n    const node = this.heap.pop();\n    delete this.nodePositionsInHeap[node.id];\n    this.siftDown(0, this.heap.length - 1, this.heap);\n    return node;\n  }\n\n  insert(node) {\n    this.heap.push(node);\n    this.nodePositionsInHeap[node.id] = this.heap.length - 1;\n    this.siftUp(this.heap.length - 1, this.heap);\n  }\n\n  swap(i, j, heap) {\n    this.nodePositionsInHeap[this.heap[i].id] = j;\n    this.nodePositionsInHeap[this.heap[j].id] = i;\n    const temp = heap[j];\n    heap[j] = heap[i];\n    heap[i] = temp;\n  }\n\n  containsNode(node) {\n    return node.id in this.nodePositionsInHeap;\n  }\n\n  update(node) {\n    this.siftUp(this.nodePositionsInHeap[node.id], this.heap);\n  }\n\n}","map":{"version":3,"names":["aStar","nodes","startNode","endNode","nodesVisited","distanceFromStart","estimatedDistanceToEnd","calculateManhattanDistance","nodesToVisit","MinHeap","isEmpty","currentMinDistanceNode","remove","push","neighbors","getNeighboringNodes","neighbor","isWall","tentativeDistanceToNeighbor","isWeight","previousNode","containsNode","insert","update","currentNode","currentRow","row","currentCol","col","endRow","endCol","Math","abs","node","grid","length","diagonal","filter","isVisited","constructor","array","nodePositionsInHeap","reduce","obj","i","id","heap","buildHeap","firstParentIdx","floor","currentIdx","siftDown","endIdx","childOneIdx","childTwoIdx","idxToSwap","swap","siftUp","parentIdx","pop","j","temp"],"sources":["/Users/aksharpandey/Documents/CODING/htmlproject-main/Path/src/Algorithms/astar.js"],"sourcesContent":["export function aStar(nodes, startNode, endNode) {\n  const nodesVisited = [];\n  startNode.distanceFromStart = 0;\n  startNode.estimatedDistanceToEnd = calculateManhattanDistance(\n    startNode,\n    endNode\n  );\n\n  const nodesToVisit = new MinHeap([startNode]);\n\n  while (!nodesToVisit.isEmpty()) {\n    const currentMinDistanceNode = nodesToVisit.remove();\n    nodesVisited.push(currentMinDistanceNode);\n    if (currentMinDistanceNode === endNode) break;\n\n    const neighbors = getNeighboringNodes(currentMinDistanceNode, nodes);\n    for (const neighbor of neighbors) {\n      if (neighbor.isWall) continue;\n\n      const tentativeDistanceToNeighbor = neighbor.isWeight\n        ? currentMinDistanceNode.distanceFromStart + 7\n        : currentMinDistanceNode.distanceFromStart + 1;\n\n      if (tentativeDistanceToNeighbor >= neighbor.distanceFromStart) continue;\n\n      neighbor.previousNode = currentMinDistanceNode;\n      neighbor.distanceFromStart = tentativeDistanceToNeighbor;\n      neighbor.estimatedDistanceToEnd =\n        tentativeDistanceToNeighbor +\n        calculateManhattanDistance(neighbor, endNode);\n\n      if (!nodesToVisit.containsNode(neighbor)) {\n        nodesToVisit.insert(neighbor);\n      } else {\n        nodesToVisit.update(neighbor);\n      }\n    }\n  }\n  return nodesVisited;\n}\n\nfunction calculateManhattanDistance(currentNode, endNode) {\n  const currentRow = currentNode.row;\n  const currentCol = currentNode.col;\n  const endRow = endNode.row;\n  const endCol = endNode.col;\n\n  return Math.abs(currentRow - endRow) + Math.abs(currentCol - endCol);\n}\n\nfunction getNeighboringNodes(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row > 0 && row % 2 === 1 && col < grid[0].length - 1) {\n    grid[row - 1][col + 1].diagonal = true;\n    neighbors.push(grid[row - 1][col + 1]);\n  }\n  if (row > 0 && row % 2 === 0 && col > 0) {\n    grid[row - 1][col - 1].diagonal = true;\n    neighbors.push(grid[row - 1][col - 1]);\n  }\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (row < grid.length - 1 && row % 2 === 1 && col < grid[0].length - 1) {\n    grid[row + 1][col + 1].diagonal = true;\n    neighbors.push(grid[row + 1][col + 1]);\n  }\n  if (row < grid.length - 1 && row % 2 === 0 && col > 0) {\n    grid[row + 1][col - 1].diagonal = true;\n    neighbors.push(grid[row + 1][col - 1]);\n  }\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n}\n\nclass MinHeap {\n  constructor(array) {\n    this.nodePositionsInHeap = array.reduce((obj, node, i) => {\n      obj[node.id] = i;\n      return obj;\n    }, {});\n    this.heap = this.buildHeap(array);\n  }\n\n  isEmpty() {\n    return this.heap.length == 0;\n  }\n\n  buildHeap(array) {\n    const firstParentIdx = Math.floor((array.length - 2) / 2);\n    for (let currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n      this.siftDown(currentIdx, array.length - 1, array);\n    }\n    return array;\n  }\n\n  siftDown(currentIdx, endIdx, heap) {\n    let childOneIdx = currentIdx * 2 + 1;\n    while (childOneIdx <= endIdx) {\n      const childTwoIdx =\n        currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n      let idxToSwap;\n      if (\n        childTwoIdx !== -1 &&\n        heap[childTwoIdx].estimatedDistanceToEnd <\n          heap[childOneIdx].estimatedDistanceToEnd\n      ) {\n        idxToSwap = childTwoIdx;\n      } else {\n        idxToSwap = childOneIdx;\n      }\n      if (\n        heap[idxToSwap].estimatedDistanceToEnd <\n        heap[currentIdx].estimatedDistanceToEnd\n      ) {\n        this.swap(currentIdx, idxToSwap, heap);\n        currentIdx = idxToSwap;\n        childOneIdx = currentIdx * 2 + 1;\n      } else {\n        return;\n      }\n    }\n  }\n\n  siftUp(currentIdx, heap) {\n    let parentIdx = Math.floor((currentIdx - 1) / 2);\n    while (\n      currentIdx > 0 &&\n      heap[currentIdx].estimatedDistanceToEnd <\n        heap[parentIdx].estimatedDistanceToEnd\n    ) {\n      this.swap(currentIdx, parentIdx, heap);\n      currentIdx = parentIdx;\n      parentIdx = Math.floor((currentIdx - 1) / 2);\n    }\n  }\n\n  remove() {\n    if (this.isEmpty()) return;\n\n    this.swap(0, this.heap.length - 1, this.heap);\n    const node = this.heap.pop();\n    delete this.nodePositionsInHeap[node.id];\n    this.siftDown(0, this.heap.length - 1, this.heap);\n    return node;\n  }\n\n  insert(node) {\n    this.heap.push(node);\n    this.nodePositionsInHeap[node.id] = this.heap.length - 1;\n    this.siftUp(this.heap.length - 1, this.heap);\n  }\n\n  swap(i, j, heap) {\n    this.nodePositionsInHeap[this.heap[i].id] = j;\n    this.nodePositionsInHeap[this.heap[j].id] = i;\n    const temp = heap[j];\n    heap[j] = heap[i];\n    heap[i] = temp;\n  }\n\n  containsNode(node) {\n    return node.id in this.nodePositionsInHeap;\n  }\n\n  update(node) {\n    this.siftUp(this.nodePositionsInHeap[node.id], this.heap);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}