{"ast":null,"code":"export function recursiveBackTrackerMaze(grid, startNode, finishNode) {\n  const stack = [startNode];\n  startNode.isVisitedMaze = true;\n\n  while (stack.length) {\n    const current = stack.pop();\n    current.isVisitedMaze = true;\n    const {\n      next,\n      wall\n    } = getRandomNeighbor(current, grid) || {\n      next: false,\n      wall: false\n    };\n\n    if (next && wall) {\n      stack.push(current);\n      next.isVisitedMaze = true;\n      next.isWall = false;\n      wall.isWall = false;\n      stack.push(next);\n    }\n  }\n\n  return grid;\n}\n\nfunction getRandomNeighbor(node, grid) {\n  const neighbors = [];\n  const wallToNeighbor = [];\n  const numRows = grid.length;\n  const numCols = grid[0].length;\n  const {\n    col,\n    row\n  } = node;\n\n  if (row > 2 && col > 1) {\n    neighbors.push(grid[row - 2][col - 1]);\n\n    if (row % 2 === 1) {\n      wallToNeighbor.push(grid[row - 1][col]);\n    } else if (row % 2 === 0) {\n      wallToNeighbor.push(grid[row - 1][col - 1]);\n    }\n  }\n\n  if (row > 2 && col < numCols - 2) {\n    neighbors.push(grid[row - 2][col + 1]);\n\n    if (row % 2 === 1) {\n      wallToNeighbor.push(grid[row - 1][col + 1]);\n    } else if (row % 2 === 0) {\n      wallToNeighbor.push(grid[row - 1][col]);\n    }\n  }\n\n  if (row < numRows - 3 && col < numCols - 2) {\n    neighbors.push(grid[row + 2][col + 1]);\n\n    if (row % 2 === 1) {\n      wallToNeighbor.push(grid[row + 1][col + 1]);\n    } else if (row % 2 === 0) {\n      wallToNeighbor.push(grid[row + 1][col]);\n    }\n  }\n\n  if (row < numRows - 3 && col > 1) {\n    neighbors.push(grid[row + 2][col - 1]);\n\n    if (row % 2 === 1) {\n      wallToNeighbor.push(grid[row + 1][col]);\n    } else if (row % 2 === 0) {\n      wallToNeighbor.push(grid[row + 1][col - 1]);\n    }\n  }\n\n  if (row > 0 && col > 2) {\n    neighbors.push(grid[row][col - 2]);\n    wallToNeighbor.push(grid[row][col - 1]);\n  }\n\n  if (row < numRows - 1 && col < numCols - 3) {\n    neighbors.push(grid[row][col + 2]);\n    wallToNeighbor.push(grid[row][col + 1]);\n  }\n\n  const newNeighbors = neighbors.slice();\n  let neighborIdx = newNeighbors.length - 1;\n\n  while (neighborIdx >= 0) {\n    let currentNeighbor = newNeighbors[neighborIdx];\n\n    if (currentNeighbor.isVisitedMaze === true) {\n      newNeighbors.splice(neighborIdx, 1);\n      wallToNeighbor.splice(neighborIdx, 1);\n    }\n\n    neighborIdx -= 1;\n  }\n\n  if (newNeighbors.length > 0) {\n    let randomVal = Math.floor(Math.random() * (newNeighbors.length - 0) + 0);\n    return {\n      next: newNeighbors[randomVal],\n      wall: wallToNeighbor[randomVal]\n    };\n  }\n}","map":{"version":3,"names":["recursiveBackTrackerMaze","grid","startNode","finishNode","stack","isVisitedMaze","length","current","pop","next","wall","getRandomNeighbor","push","isWall","node","neighbors","wallToNeighbor","numRows","numCols","col","row","newNeighbors","slice","neighborIdx","currentNeighbor","splice","randomVal","Math","floor","random"],"sources":["/Users/aksharpandey/Documents/CODING/htmlproject-main/Path/src/Algorithms/MazeAlgorithms/recursive-backtracker.js"],"sourcesContent":["export function recursiveBackTrackerMaze(grid, startNode, finishNode) {\n  const stack = [startNode];\n  startNode.isVisitedMaze = true;\n\n  while (stack.length) {\n    const current = stack.pop();\n\n    current.isVisitedMaze = true;\n\n    const { next, wall } = getRandomNeighbor(current, grid) || {\n      next: false,\n      wall: false,\n    };\n\n    if (next && wall) {\n      stack.push(current);\n      next.isVisitedMaze = true;\n      next.isWall = false;\n      wall.isWall = false;\n\n      stack.push(next);\n    }\n  }\n  return grid;\n}\n\nfunction getRandomNeighbor(node, grid) {\n  const neighbors = [];\n  const wallToNeighbor = [];\n  const numRows = grid.length;\n  const numCols = grid[0].length;\n  const { col, row } = node;\n\n  if (row > 2 && col > 1) {\n    neighbors.push(grid[row - 2][col - 1]);\n    if (row % 2 === 1) {\n      wallToNeighbor.push(grid[row - 1][col]);\n    } else if (row % 2 === 0) {\n      wallToNeighbor.push(grid[row - 1][col - 1]);\n    }\n  }\n  if (row > 2 && col < numCols - 2) {\n    neighbors.push(grid[row - 2][col + 1]);\n    if (row % 2 === 1) {\n      wallToNeighbor.push(grid[row - 1][col + 1]);\n    } else if (row % 2 === 0) {\n      wallToNeighbor.push(grid[row - 1][col]);\n    }\n  }\n  if (row < numRows - 3 && col < numCols - 2) {\n    neighbors.push(grid[row + 2][col + 1]);\n    if (row % 2 === 1) {\n      wallToNeighbor.push(grid[row + 1][col + 1]);\n    } else if (row % 2 === 0) {\n      wallToNeighbor.push(grid[row + 1][col]);\n    }\n  }\n  if (row < numRows - 3 && col > 1) {\n    neighbors.push(grid[row + 2][col - 1]);\n    if (row % 2 === 1) {\n      wallToNeighbor.push(grid[row + 1][col]);\n    } else if (row % 2 === 0) {\n      wallToNeighbor.push(grid[row + 1][col - 1]);\n    }\n  }\n  if (row > 0 && col > 2) {\n    neighbors.push(grid[row][col - 2]);\n    wallToNeighbor.push(grid[row][col - 1]);\n  }\n  if (row < numRows - 1 && col < numCols - 3) {\n    neighbors.push(grid[row][col + 2]);\n    wallToNeighbor.push(grid[row][col + 1]);\n  }\n\n  const newNeighbors = neighbors.slice();\n  let neighborIdx = newNeighbors.length - 1;\n\n  while (neighborIdx >= 0) {\n    let currentNeighbor = newNeighbors[neighborIdx];\n\n    if (currentNeighbor.isVisitedMaze === true) {\n      newNeighbors.splice(neighborIdx, 1);\n      wallToNeighbor.splice(neighborIdx, 1);\n    }\n\n    neighborIdx -= 1;\n  }\n\n  if (newNeighbors.length > 0) {\n    let randomVal = Math.floor(Math.random() * (newNeighbors.length - 0) + 0);\n\n    return { next: newNeighbors[randomVal], wall: wallToNeighbor[randomVal] };\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}